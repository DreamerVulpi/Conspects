##Клиент-серверные базы данных
###Лекция №1-2.
***
**Read Uncommitted**

На уровне изоляции Read Uncommitted транкзакции могут видеть результаты незафиксированных транкзакций

Чтение незафиксированных данных называют "грязным чтением".

**Read Committed**

На этом уровне возможен феномен невоспроизводимого чтения (*nonrepeatable read*). Это означает, что вы можете выполнить одну и ту же команду дважды и получить различный результат.

**Repeatable Read**

На этом уровне возможен феномен фантомного чтения (*phantom reads*). Попросту говоря, фантомное чтение может происходить в случае, если вы выбираете некоторый диапазон строк, затем другая транкзакция вставляет новую строку в этот диапазон, после чего вы выбираете тот же лиапазон снова. В результате вы видете фантомную строку.

От невоиспроизводимого чтения оно отличается тем, что результат повторного обращения к данным изменился не из-за изменения/удаления самих этих данных, а из-за появления новых (фантомных) данных. PostgreSQL не допускает "фантомного" чтения.

**Serializable**

Уровень Serializable блокирует каждую строку, которая транкзакция читает (т.е с той, с короторой работаете). На этом уровне может возникать множество задержек и конфликтов при блокировках.

При этом уровне параллельные транкзакции одновременно не смогут быть выполнены. Одна из них будет откатана.

|Уровень изоляции|Потерянное обновление|"Грязное" чтение|Невоспроизводимое чтение|Фантомное чтение|Аномалии сериализации|
|------|------|------|------|------|------|
|Read Uncommitted|Нет|Да|Да|Да|Нет|
|Read Committed|Нет|Нет|Да|Да|Нет|
|Repeatable Read|Нет|Нет|Нет|Да|Нет|
|Serializable|Нет|Нет|Нет|Нет|Да|

**Блокировки**

Так же в СУБД существует механизм блокировок. Блокировки бывают на всю таблицу, но этот механизм практически уже не используют. Чаще всего используют блокировки на отдельные записи таблицы. Рассмотрим пример, когда две параллельные транкзакции пытаются изменить одну и туже строку таблицы.

***
##Лекция №2

**Применение индексов**
* Быстрый поиск по условию where;
* Объединение таблиц по средствам join. Необходимо использовать одинаковый тип полей.;
* Выборка наименьшего количества записей из таблицы;
* Поиск min и max значений для ключевых полей;
* Сортировка и группировка таблиц;
* Извлечение данных не из таблицы, а из индексного файла;

**Типы индексов**
* btree;
* hash-индексы;
* Gist(R-tree);
* GIN(инвентированный);
* Битовый;
* Частичный;
* Функциональный;
* Кластерный;
* Покрывающий;

**Создание индекса**
```
Create index index_name ON tbl_name Using index_type;
```

**Btree**
Самый классический индекс - это сбалансированное дерево.

Этот индекс создаётся по умолчанию, если явно не задан тип индекса.

|Преимущества|Недостатки|
|------|------|
|+ поиск по полному значению;|- поиск без использования левой части ключа;|
|+ поиск по самому левому префиксу;|- нельзя пропускать столбцы;|
|+ поиск по префиксу столбца;|- оптимизация после поиска в диапазоне;|
|+ поиск по диапазону значений;||
|+ поиск по полному совпадению одному части и диапазону в другой части;||
|+ запросы только по индексу;||

```
Like '%a' - может быть сколько угодно букв, но на конце 'a'
```

Пример таблицы

```
Create Table people
{
Iname Text Not Full,
fname Text Not Null,
dob Timestamp Not Full
);

Create Index idx_people_name ON people Using btree(lname, fname, dob);
```

**Hash-индексы**
```
Create Temporary Table tmp_people
(
fname Text Not Full,
lname Text Not Full
);

Create Index idx_tmp_people_fname ON tmp_people Using hash(fname);

```

**Особенности**
* Нельзя использовать данные в индексе, чтобы избежать чтения строк;
* Нельзя использовать для сортировки;
* используются только для сравнений;
Этот тип индексов не пишется в журнал транзакций. Его нельзя использовать для реальных таблиц. Сама СУБД активно использует этот тип индексов для JOIN.

**Gist(R-tree)**

Активно используются для географических типов данных.
```
Create Table city (
id Serial Primary Key,
name Text Not Null,
area polygon
);

Create Index idx_city_area ON city Using gist(area);
```

**Gin(инвертированный)**

Этот тип индекса активно используется для поиска по полнотекстовым полям, по полям тип JSON. По сути он указывает в каких полях содержится данный ключ.

```
Create Table movies (
id Serial Primaty Key,
title Text Not Full,
genres Text[] Not Null
);

Create Index idx_movies_genres ON movies Using gin(genres);
```

**Битовый индекс**

Этот тип индексов скрыт от пользователя

Его невозможно создать вручную, однако он активно используется внутри СУБД.

Если у нас есть поле, которое отвечает на вопрос "да-нет", то к нему будет активно применяться битовый индекс

По выбираемому полю строится битовая маска, показывающая где какое значение.

**Частичный**

```
Create Table items(
id Serial Primary Key,
a_id INT NULL,
b_id INT NULL,
c_id NULL,
Check (Case When a_id is Null Then 1 else 0 end +
Case When b_id Null Then 1 else 0 end +
Case When c_id is Null Then 1 else 0 end = 1));
Create Index idx_a_items ON items(a_id) Where a_id Is Not Null;
```

**Функциональный**

```
Create Table m (
id serial primaty Key,
Title Text Not Null,
genres text[] not null
);

Create index idx_m_title on m(lower(title));
Select * from m where lower(title) = lower('lalala');
```
Хорошим тоном по поиску в БД - приводить всё к одному регистру

**Кластерный (тупо метод сортировки таблиц)**

```
Create Table movies (
id Serial Primary Key,
Title Text Not Null
);
cluster m using m_pkey;
cluster m;
cluster;
```
Кластерный индекс (или кластерный ключ) сохраняет не только значения колонки в отсортированном виде, а и данные всей строки.

Это позволяет минимизировать количество операций чтения с диска при работе с таким индексом. В таблице может быть только один кластерный индекс.

**Покрывающий**

```
Create Table test
(
id Serial Primary Key,
title Text Not NULL
);

Create Index idx_test_title ON test (title);
Select title From test Where title = 'X';
```
Покрывающий индекс содержит все данные, необходимые для выполнения запроса.

**Индексы. Итоги**
* Увеличение числа индексов замедляет операции добавления, обновления, удаления строк таблицы, поскольку при этому приходится обновлять сами индексы.
* Индексы занимают дополнительный объём памяти, поэтому перед созданием индекса следует убедиться, что планируемый выигрыш в производительности запросов превысит дополнительную затрату ресурсов компьютера на сопровождение индекса.
* В большинстве случаев нужен btree-индекс;
* Для специфических случаев нужны GIN и GIST-индексы;
* Битовые и hash-индексы PostgreSQL активно использует в процессе выполнения запросов;
* Частичные индексы могут заметно сократить объём индексов;
* В PostgreSQL нужно явно создавать индексы для FOREIGN KEY;
* Можно получить очень большой прирост производительности при использовании покрывающих индексов;
* Каждый индекс требует дополнительных затрат на своё содержание;


